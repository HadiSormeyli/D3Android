const margin = { top: 0, right: 0, bottom: 0, left: 0 };
const width = window.innerWidth - margin.left - margin.right;
const height = window.innerHeight - margin.top - margin.bottom;

const outerSvg = d3.select("svg")
    .attr("width", width)
    .attr("height", height);

const zoomLayer = outerSvg.append("g");

let currentRoot = null;
let historyStack = [];
let currentScale = 1;
let allData = []

function containsCurrentRootName(node) {
    if(!currentRoot) {
        return false;
    }

    if (node.name === currentRoot.data.name) {
        return true;
    }

    if (node.children) {
        for (let child of node.children) {
            if (child.name == currentRoot.data.name) {
                return true;
            }
        }
    }
    return false;
}

function setData(data) {
    console.log("Received data:", data);
    allData = data;
    const root = d3.hierarchy(data)
        .sum(d => d.value)
        .sort((a, b) => b.value - a.value);

    if (!containsCurrentRootName(data)) {
        currentRoot = root;
    }

    drawTreemap(currentRoot);
}

function getColor(d) {
    if (!d.children) {
        if (d.data.colorValue > 0) return "#69b3a2";
        if (d.data.colorValue === 0) return "#888";
        return "#ff6347";
    }
    return "#434753";
}

function textFits(d, scale = 1) {
    const boxWidth = (d.x1 - d.x0) * scale;
    const boxHeight = (d.y1 - d.y0) * scale;
    const avgCharWidth = 8;
    const lineHeight = 14;
    const textLines = 2;

    const maxLineLength = Math.max(
        d.data.name.length * avgCharWidth,
        String(d.value).length * avgCharWidth
    );

    return maxLineLength <= boxWidth && (lineHeight * textLines) <= boxHeight;
}

function findNodeByName(name, node = allData) {
    if (node.name === name) return node;
    if (!node.children) return null;

    for (let child of node.children) {
        const found = findNodeByName(name, child);
        if (found) return found;
    }
    return null;
}

function drawTreemap(rootNode) {
    zoomLayer.selectAll("*").remove();

    const treemap = d3.treemap()
        .size([width, height])
        .paddingInner(1)
        .paddingTop(20)
        .round(true);

    const rootCopy = d3.hierarchy(rootNode.data ? rootNode.data : rootNode)
        .sum(d => d.value)
        .sort((a, b) => b.value - a.value);

    treemap(rootCopy);

    const allNodes = zoomLayer.selectAll(".node")
        .data(rootCopy.descendants())
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x0}, ${d.y0})`);

    allNodes.append("rect")
        .attr("width", d => d.x1 - d.x0)
        .attr("height", d => d.y1 - d.y0)
        .style("fill", d => getColor(d))
        .on("click", function (event, d) {
            if (d.children && d.data !== currentRoot.data) {
                event.stopPropagation();
                historyStack.push(currentRoot.data.name);
                currentRoot = d;
                drawTreemap(d);

                outerSvg
                    .call(zoom.transform, d3.zoomIdentity);

            }
        });

    const textGroups = allNodes.filter(d => !d.children)
        .append("g")
        .attr("class", d => `text-group ${textFits(d, currentScale) ? "visible-text" : "hidden-text"}`);

    textGroups.append("text")
        .attr("class", "label")
        .style("font-size", d => `${0.75 / currentScale}em`)
        .attr("x", d => (d.x1 - d.x0) / 2)
        .attr("y", d => (d.y1 - d.y0) / 2)
        .attr("text-anchor", "middle")
        .append("tspan")
        .text(d => d.data.name)
        .attr("dy", "-0.5em")
        .attr("x", d => (d.x1 - d.x0) / 2)
        .append("tspan")
        .text(d => d.data.value)
        .attr("dy", "1.2em")
        .attr("x", d => (d.x1 - d.x0) / 2);

    allNodes.filter(d => d.children).append("text")
        .attr("class", "header")
        .attr("x", d => (d.x1 - d.x0) / 2)
        .attr("y", 16)
        .attr("text-anchor", "middle")
        .text(d => d.data.name);
}


function updateTextVisibility() {
    zoomLayer.selectAll(".label")
        .style("font-size", d => `${0.75 / currentScale}em`);
    zoomLayer.selectAll(".text-group")
        .classed("visible-text", d => textFits(d, currentScale))
        .classed("hidden-text", d => !textFits(d, currentScale));
}

function onBackPressed() {
    console.log("onBackPressed");
    if (historyStack.length > 0) {
        const lastName = historyStack.pop();
        let nodeData = findNodeByName(lastName);

        if (!nodeData) {
            nodeData = allData;
        }

        const nodeHierarchy = d3.hierarchy(nodeData)
            .sum(d => d.value)
            .sort((a, b) => b.value - a.value);

        currentRoot = nodeHierarchy;
        drawTreemap(nodeHierarchy);


        outerSvg.call(zoom.transform, d3.zoomIdentity);

        return true;
    }
    return false;
}

let zoomAnimationFrame;
const zoom = d3.zoom()
    .scaleExtent([1, 25])
    .translateExtent([[0, 0], [width, height]])
    .on("zoom", function(event) {
        if (zoomAnimationFrame) {
            cancelAnimationFrame(zoomAnimationFrame);
        }

        zoomAnimationFrame = requestAnimationFrame(() => {
            const t = event.transform;
            const constrainedTransform = constrainTransform(t, width, height);
            zoomLayer.attr("transform", constrainedTransform);
            currentScale = t.k;

            // Only update text visibility if zoom has significantly changed
            if (Math.abs(t.k - lastScale) > 0.1) {
                updateTextVisibility();
                lastScale = t.k;
            }
        });
    });
let lastScale = 1;

function constrainTransform(transform, width, height) {
    const scaledWidth = width * transform.k;
    const scaledHeight = height * transform.k;

    const tx = Math.min(0, Math.max(width - scaledWidth, transform.x));
    const ty = Math.min(0, Math.max(height - scaledHeight, transform.y));

    return d3.zoomIdentity.translate(tx, ty).scale(transform.k);
}

window.onload = function () {
    console.log("Waiting for port from Android via postMessage...");
};

 function handleMessage(event, port) {
    const message = event.data;
    try {
      const parsed = JSON.parse(message);

      if (parsed.data && parsed.data.fn === "setData") {
        const jsonString = parsed.data.params.data;
        const data = JSON.parse(jsonString);
        setData(data);
      } else if(parsed.data.fn === "onBackPressed") {
        const result = onBackPressed();
        const response = {
                messageType: "Message::FunctionResult",
                data: {
                                       fn: parsed.data.fn,
                                       uuid: parsed.data.uuid,
                                       result: result
                                   }
            };

            port.postMessage(JSON.stringify(response));
      }
    } catch (e) {
      console.error("Error handling message", e);
    }
  }

window.addEventListener("message", function(event) {
    if (event.ports && event.ports.length > 0) {
        const port = event.ports[0];
        port.onmessage = (e) => handleMessage(e, port);
        port.start?.();
    }
});

outerSvg.call(zoom);
